```javascript
const utils = require('../bin/utils');
const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const openai = require('openai');

describe('Utils Module', () => {
  describe('readFile() Function', () => {
    test('Should read file content correctly', () => {
      const path = 'path/to/file';
      const expectedContent = 'This is the file content';
      jest.spyOn(fs, 'readFileSync').mockReturnValue(expectedContent);
      
      const result = utils.readFile(path);

      expect(fs.readFileSync).toHaveBeenCalledWith(path, 'utf-8');
      expect(result).toBe(expectedContent);
    });

    test('Should handle error when reading file', () => {
      const path = 'path/to/nonexistent/file';
      jest.spyOn(fs, 'readFileSync').mockImplementation(() => {
        throw new Error();
      });

      const result = utils.readFile(path);

      expect(fs.readFileSync).toHaveBeenCalledWith(path, 'utf-8');
      expect(result).toBe('');
      expect(console.error).toHaveBeenCalled();
    });
  });

  describe('writeToFile() Function', () => {
    test('Should write content to file correctly', () => {
      const path = 'path/to/file';
      const content = 'This is the file content';
      const append = false;

      utils.writeToFile(path, content, append);

      expect(fs.writeFileSync).toHaveBeenCalledWith(path, content, { flag: 'w' });
      expect(console.log).toHaveBeenCalledWith(chalk.green(`Successfully wrote to file: ${path}`));
    });

    test('Should append content to file correctly', () => {
      const path = 'path/to/file';
      const content = 'This is the file content';
      const append = true;

      utils.writeToFile(path, content, append);

      expect(fs.writeFileSync).toHaveBeenCalledWith(path, content, { flag: 'a' });
      expect(console.log).toHaveBeenCalledWith(chalk.green(`Successfully wrote to file: ${path}`));
    });

    test('Should handle error when writing to file', () => {
      const path = 'path/to/nonexistent/file';
      const content = 'This is the file content';
      const append = false;
      jest.spyOn(fs, 'writeFileSync').mockImplementation(() => {
        throw new Error();
      });

      utils.writeToFile(path, content, append);

      expect(fs.writeFileSync).toHaveBeenCalledWith(path, content, { flag: 'w' });
      expect(console.error).toHaveBeenCalled();
    });
  });

  describe('divideFileName() Function', () => {
    test('Should divide a file name into name and extension', () => {
      const fileName = 'example.js';
      const expectedName = 'example';
      const expectedExtension = '.js';

      const result = utils.divideFileName(fileName);

      expect(result.name).toBe(expectedName);
      expect(result.extension).toBe(expectedExtension);
    });
  });

  describe('getFileType() Function', () => {
    test('Should return File type when given a file path', () => {
      const path = 'path/to/file.js';

      const result = utils.getFileType(path);

      expect(fs.lstatSync).toHaveBeenCalledWith(path);
      expect(fs.lstatSync().isDirectory).toHaveBeenCalled();
      expect(result).toBe(utils.EFileType.File);
    });

    test('Should return Directory type when given a directory path', () => {
      const path = 'path/to/directory';

      const result = utils.getFileType(path);

      expect(fs.lstatSync).toHaveBeenCalledWith(path);
      expect(fs.lstatSync().isDirectory).toHaveBeenCalled();
      expect(result).toBe(utils.EFileType.Directory);
    });

    test('Should handle error when getting file type', () => {
      const path = 'path/to/nonexistent/file';
      jest.spyOn(fs, 'lstatSync').mockImplementation(() => {
        throw new Error();
      });

      const result = utils.getFileType(path);

      expect(fs.lstatSync).toHaveBeenCalledWith(path);
      expect(console.error).toHaveBeenCalled();
      expect(result).toBe(utils.EFileType.File);
    });
  });

  describe('toList() Function', () => {
    test('Should return a string representation of the array elements', () => {
      const arr = ['Item 1', 'Item 2', 'Item 3'];
      const expectedString = '1. Item 1\r\n2. Item 2\r\n3. Item 3';

      const result = utils.toList(arr);

      expect(result).toBe(expectedString);
    });
  });

  describe('parseTemplatePrompt() Function', () => {
    test('Should parse and replace template placeholders with provided arguments', () => {
      const template = 'Hello, {name}!';
      const args = { name: 'John' };
      const expectedPrompt = 'Hello, John!';

      const result = utils.parseTemplatePrompt(template, args);

      expect(result).toBe(expectedPrompt);
    });
  });

  describe('getPrompt() Function', () => {
    test('Should generate a prompt based on the provided arguments', () => {
      const content = 'This is the file content';
      const fileName = 'example.js';
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      const promptTemplate = 'This is a template';
      const expectedPrompt = 'This is a template';

      const result = utils.getPrompt({ content, fileName, techs, instructions, promptTemplate });

      expect(result).toBe(expectedPrompt);
    });

    test('Should generate a default prompt without template', () => {
      const content = 'This is the file content';
      const fileName = 'example.js';
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      const expectedPrompt = `Please provide unit tests for the file ${fileName} using ${techs}
${instructions}

Please begin your response with \`\`\` and end it with \`\`\` directly.

Here is the file content:
\`\`\`${content}\`\`\``;

      const result = utils.getPrompt({ content, fileName, techs, instructions });

      expect(result).toBe(expectedPrompt);
    });
  });

  describe('getExampleMessages() Function', () => {
    test(`Should return an array of example messages based on the provided prompt arguments and examples`, () => {
      const promptArgs = {
        content: 'This is the file content',
        fileName: 'example.js',
        techs: ['JavaScript', 'Node.js'],
        instructions: ['Step 1', 'Step 2'],
        promptTemplate: 'This is a template'
      };
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const expectedMessages = [
        { role: 'User', content: 'This is a template' },
        { role: 'Assistant', content: 'Example tests 1' },
        { role: 'User', content: 'This is a template' },
        { role: 'Assistant', content: 'Example tests 2' },
      ];

      const result = utils.getExampleMessages(promptArgs, examples);

      expect(result).toEqual(expectedMessages);
    });

    test('Should return an empty array when examples is undefined', () => {
      const promptArgs = {
        content: 'This is the file content',
        fileName: 'example.js',
        techs: ['JavaScript', 'Node.js'],
        instructions: ['Step 1', 'Step 2'],
        promptTemplate: 'This is a template'
      };
      const examples = undefined;
      const expectedMessages = [];

      const result = utils.getExampleMessages(promptArgs, examples);

      expect(result).toEqual(expectedMessages);
    });
  });

  describe('readYamlFile() Function', () => {
    test('Should parse and return the content of a YAML file', () => {
      const path = 'path/to/yaml/file';
      const content = 'key: value\n';
      jest.spyOn(fs, 'readFileSync').mockReturnValue(content);
      jest.spyOn(utils.yaml, 'parse').mockReturnValue({ key: 'value' });

      const result = utils.readYamlFile(path);

      expect(fs.readFileSync).toHaveBeenCalledWith(path, 'utf-8');
      expect(utils.yaml.parse).toHaveBeenCalledWith(content);
      expect(result).toEqual({ key: 'value' });
    });
  });

  describe('initOpenAI() Function', () => {
    test('Should initialize OpenAI instance with the provided API key', async () => {
      const apiKey = 'ABCD1234';
      const mockOpenAI = {
        apiKey: apiKey,
      };
      jest.spyOn(openai, 'default').mockReturnValue(mockOpenAI);

      const result = await utils.initOpenAI(apiKey);

      expect(openai.default).toHaveBeenCalledWith({ apiKey });
      expect(result).toBe(mockOpenAI);
    });
  });

  describe('getMessages() Function', () => {
    test('Should generate a list of messages based on the system message, prompt, and examples', () => {
      const systemMessage = 'System message';
      const prompt = 'Prompt message';
      const examples = [
        { role: 'User', content: 'Example code' },
        { role: 'Assistant', content: 'Example tests' }
      ];
      const expectedMessages = [
        { role: 'System', content: systemMessage },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code' },
        { role: 'Assistant', content: 'Example tests' }
      ];

      const result = utils.getMessages(systemMessage, prompt, examples);

      expect(result).toEqual(expectedMessages);
    });
  });

  describe('getTestContent() Function', () => {
    test('Should send a request to OpenAI API and return the generated test content', async () => {
      const openaiClient = {
        chat: {
          completions: {
            create: jest.fn().mockResolvedValue({
              choices: [{ message: { content: 'Generated tests' } }]
            })
          }
        }
      };
      const model = 'gpt-3.5-turbo';
      const messages = [
        { role: 'System', content: 'System message' },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code' },
        { role: 'Assistant', content: 'Example tests' }
      ];
      const expectedTestContent = 'Generated tests';

      const result = await utils.getTestContent({ model, messages, openai: openaiClient });

      expect(openaiClient.chat.completions.create).toHaveBeenCalledWith({ model, messages });
      expect(result).toBe(expectedTestContent);
    });
  });

  describe('streamTestContent() Function', () => {
    test('Should send a request to OpenAI API and stream the generated test content', async () => {
      const openaiClient = {
        chat: {
          completions: {
            create: jest.fn().mockResolvedValue({
              [Symbol.asyncIterator]: jest.fn().mockResolvedValue({
                next: jest.fn().mockResolvedValue({ value: { choices: [{ delta: { content: 'Generated tests' } }] }, done: false } ),
                return: jest.fn()
              })
            })
          }
        }
      };
      const model = 'gpt-3.5-turbo';
      const messages = [
        { role: 'System', content: 'System message' },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code' },
        { role: 'Assistant', content: 'Example tests' }
      ];

      await utils.streamTestContent({ model, messages, openai: openaiClient, onToken: jest.fn() });

      expect(openaiClient.chat.completions.create).toHaveBeenCalledWith({ model, messages, stream: true });
    });

    test('Should call the onToken function with each token of the generated test content', async () => {
      const openaiClient = {
        chat: {
          completions: {
            create: jest.fn().mockResolvedValue({
              [Symbol.asyncIterator]: jest.fn().mockResolvedValue({
                next: jest.fn()
                  .mockResolvedValueOnce({ value: { choices: [{ delta: { content1: 'Token 1' } }] }, done: false })
                  .mockResolvedValueOnce({ value: { choices: [{ delta: { content2: 'Token 2' } }] }, done: false })
                  .mockResolvedValueOnce({ value: { choices: [{ delta: { content3: 'Token 3' } }] }, done: false })
                  .mockResolvedValueOnce({ value: { choices: [{ delta: { content4: 'Token 4' } }] }, done: false })
                  .mockResolvedValueOnce({ value: { choices: [{ delta: { content5: 'Token 5' } }] }, done: true }),
                return: jest.fn()
              })
            })
          }
        }
      };
      const model = 'gpt-3.5-turbo';
      const messages = [
        { role: 'System', content: 'System message' },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code' },
        { role: 'Assistant', content: 'Example tests' }
      ];
      const onToken = jest.fn();

      const expectedTokens = ['Token 1', 'Token 2', 'Token 3', 'Token 4', 'Token 5'];

      await utils.streamTestContent({ model, messages, openai: openaiClient, onToken });

      expect(onToken).toHaveBeenCalledTimes(5);
      expect(onToken).toHaveBeenNthCalledWith(1, 'Token 1');
      expect(onToken).toHaveBeenNthCalledWith(2, 'Token 2');
      expect(onToken).toHaveBeenNthCalledWith(3, 'Token 3');
      expect(onToken).toHaveBeenNthCalledWith(4, 'Token 4');
      expect(onToken).toHaveBeenNthCalledWith(5, 'Token 5');
    });
  });

  describe('autoTest() Function', () => {
    afterEach(() => {
      jest.resetAllMocks();
    });

    test('Should read input file, generate tests using OpenAI API, and write them to the output file', async () => {
      const inputFile = 'path/to/input/file';
      const outputFile = 'path/to/output/file';
      const apiKey = 'ABCD1234';
      const model = 'gpt-3.5-turbo';
      const systemMessage = 'System message';
      const promptTemplate = 'This is a template';
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      jest.spyOn(fs, 'readFileSync');
      jest.spyOn(fs, 'writeFileSync');
      jest.spyOn(console, 'log');
      jest.spyOn(console, 'error');
      const messages = [
        { role: 'System', content: systemMessage },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code 1' },
        { role: 'Assistant', content: 'Example tests 1' }
      ];
      const expectedTestContent = 'Generated tests';

      const result = utils.autoTest({ inputFile, outputFile, apiKey, model, systemMessage, promptTemplate, examples, techs, instructions, stream: false });

      await expect(result).resolves.toBe(undefined);
      expect(fs.readFileSync).toHaveBeenCalledWith(inputFile, 'utf-8');
      expect(fs.writeFileSync).toHaveBeenCalledWith(outputFile, expectedTestContent, { flag: 'w' });
      expect(openai.default).toHaveBeenCalledWith({ apiKey });
      expect(openaiClient.chat.completions.create).toHaveBeenCalledWith({ model, messages });
      expect(console.log).toHaveBeenCalledWith(chalk.green(`Successfully wrote to file: ${outputFile}`));
    });

    test('Should handle error when reading input file', async () => {
      const inputFile = 'path/to/nonexistent/file';
      const outputFile = 'path/to/output/file';
      const apiKey = 'ABCD1234';
      const model = 'gpt-3.5-turbo';
      const systemMessage = 'System message';
      const promptTemplate = 'This is a template';
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      jest.spyOn(fs, 'readFileSync').mockImplementation(() => {
        throw new Error();
      });
      jest.spyOn(fs, 'writeFileSync');
      jest.spyOn(console, 'log');
      jest.spyOn(console, 'error');

      const result = utils.autoTest({ inputFile, outputFile, apiKey, model, systemMessage, promptTemplate, examples, techs, instructions, stream: false });

      await expect(result).resolves.toBe(undefined);
      expect(fs.readFileSync).toHaveBeenCalledWith(inputFile, 'utf-8');
      expect(fs.writeFileSync).not.toHaveBeenCalled();
      expect(console.error).toHaveBeenCalled();
    });

    test('Should handle error when writing to output file', async () => {
      const inputFile = 'path/to/input/file';
      const outputFile = 'path/to/nonexistent/directory/file';
      const apiKey = 'ABCD1234';
      const model = 'gpt-3.5-turbo';
      const systemMessage = 'System message';
      const promptTemplate = 'This is a template';
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      jest.spyOn(fs, 'readFileSync');
      jest.spyOn(fs, 'writeFileSync').mockImplementation(() => {
        throw new Error();
      });
      jest.spyOn(console, 'log');
      jest.spyOn(console, 'error');
      const messages = [
        { role: 'System', content: systemMessage },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code 1' },
        { role: 'Assistant', content: 'Example tests 1' }
      ];
      const expectedTestContent = 'Generated tests';

      const result = utils.autoTest({ inputFile, outputFile, apiKey, model, systemMessage, promptTemplate, examples, techs, instructions, stream: false });

      await expect(result).resolves.toBe(undefined);
      expect(fs.readFileSync).toHaveBeenCalledWith(inputFile, 'utf-8');
      expect(fs.writeFileSync).toHaveBeenCalledWith(outputFile, expectedTestContent, { flag: 'w' });
      expect(console.log).not.toHaveBeenCalled();
      expect(console.error).toHaveBeenCalled();
    });

    test('Should handle error when generating tests - No tests content', async () => {
      const inputFile = 'path/to/input/file';
      const outputFile = 'path/to/output/file';
      const apiKey = 'ABCD1234';
      const model = 'gpt-3.5-turbo';
      const systemMessage = 'System message';
      const promptTemplate = 'This is a template';
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const techs = ['JavaScript', 'Node.js'];
      const instructions = ['Step 1', 'Step 2'];
      jest.spyOn(fs, 'readFileSync');
      jest.spyOn(fs, 'writeFileSync');
      jest.spyOn(console, 'log');
      jest.spyOn(console, 'error');
      const messages = [
        { role: 'System', content: systemMessage },
        { role: 'User', content: 'Prompt message' },
        { role: 'Assistant', content: 'Example code 1' },
        { role: 'Assistant', content: 'Example tests 1' }
      ];
      jest.spyOn(openai, 'default').mockReturnValue({
        chat: {
          completions: {
            create: jest.fn().mockResolvedValue({
              choices: [{ message: undefined }]
            })
          }
        }
      });

      const result = utils.autoTest({ inputFile, outputFile, apiKey, model, systemMessage, promptTemplate, examples, techs, instructions, stream: false });

      await expect(result).resolves.toBe(undefined);
      expect(fs.readFileSync).toHaveBeenCalledWith(inputFile, 'utf-8');
      expect(fs.writeFileSync).not.toHaveBeenCalled();
      expect(openai.default).toHaveBeenCalledWith({ apiKey });
      expect(console.error).toHaveBeenCalled();
    });

    test('Should write tests to output file using model endpoint instead of OpenAI API', async () => {
      const inputFile = 'path/to/input/file';
      const outputFile = 'path/to/output/file';
      const apiKey = 'ABCD1234';
      const model = 'gpt-3.5-turbo';
      const systemMessage = 'System message';
      const promptTemplate = 'This is a template';
      const examples = [
        {
          code: 'Example code 1',
          fileName: 'example1.js',
          tests: 'Example tests 1',
        },
        {
          code: 'Example code 2',
          fileName: 'example2.js',
          tests: 'Example tests 2',
        }
      ];
      const modelEndpoint = 'http://localhost:5000/test-generator';
      jest.spyOn(fs, 'readFileSync');
      jest.spyOn(fs, 'writeFileSync');
      jest.spyOn(console, 'log');
      jest.spyOn(console, 'error');
      const prompt = 'Prompt message';
      const expectedTestContent = 'Generated tests';
      jest.spyOn(global, 'fetch').mockResolvedValue({
        text: jest.fn().mockResolvedValue(expectedTestContent),
      });

      const result = utils.autoTest({ inputFile, outputFile, apiKey, model, systemMessage, promptTemplate, examples, modelEndpoint });

      await expect(result).resolves.toBe(undefined);
      expect(fs.readFileSync).toHaveBeenCalledWith(inputFile, 'utf-8');
      expect(fs.writeFileSync).toHaveBeenCalledWith(outputFile, expectedTestContent, { flag: 'w' });
      expect(console.log).toHaveBeenCalledWith(chalk.green(`Successfully wrote to file: ${outputFile}`));
      expect(global.fetch).toHaveBeenCalledWith(modelEndpoint, { method: 'POST', body: expect.any(String), headers: expect.any(Object) });
    });
  });
});
```
```